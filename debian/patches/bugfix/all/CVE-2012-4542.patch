diff --git a/block/bsg.c b/block/bsg.c
index 420a5a9..5f65841 100644
--- a/block/bsg.c
+++ b/block/bsg.c
@@ -187,7 +187,7 @@ static int blk_fill_sgv4_hdr_rq(struct request_queue *q, struct request *rq,
 		return -EFAULT;
 
 	if (hdr->subprotocol == BSG_SUB_PROTOCOL_SCSI_CMD) {
-		if (blk_verify_command(rq->cmd, has_write_perm))
+		if (blk_verify_command(rq->cmd, has_write_perm, q->sgio_type))
 			return -EPERM;
 	} else if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
diff --git a/block/scsi_ioctl.c b/block/scsi_ioctl.c
index 4044cf7..ece5399 100644
--- a/block/scsi_ioctl.c
+++ b/block/scsi_ioctl.c
@@ -197,7 +197,8 @@ static void blk_set_cmd_filter_defaults(struct blk_cmd_filter *filter)
 	__set_bit(GPCMD_SET_READ_AHEAD, filter->write_ok);
 }
 
-int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm)
+int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm,
+		unsigned char sgio_type)
 {
 	struct blk_cmd_filter *filter = &blk_default_cmd_filter;
 
@@ -210,12 +211,46 @@ int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm)
 		return 0;
 
 	/* Anybody who can open the device can do a read-safe command */
-	if (test_bit(cmd[0], filter->read_ok))
-		return 0;
+	if (test_bit(cmd[0], filter->read_ok)) {
+		/* REPORT_KEY is only permitted on ROM devices */
+		if (cmd[0] == GPCMD_REPORT_KEY && sgio_type != TYPE_ROM)
+			return -EPERM;
+
+		/* Some device-specific command codes clash. Check for
+		 * those which require write access to ensure that the
+		 * user has write permissions before using them:
+		 *
+		 * READ_SUBCHANNEL =:= UNMAP
+		 * PLAY_AUDIO_TI   =:= SANITIZE
+		 * READ_DISC_INFO  =:= XPWRITE
+		 * GET_PERFORMANCE =:= ERASE
+		 */
+		if (sgio_type == TYPE_DISK &&
+				cmd[0] != GPCMD_READ_SUBCHANNEL &&
+				cmd[0] != GPCMD_PLAY_AUDIO_TI &&
+				cmd[0] != GPCMD_READ_DISC_INFO) {
+			return 0;
+		} else if (sgio_type == TYPE_RBC &&
+				cmd[0] != GPCMD_PLAY_AUDIO_TI) {
+			return 0;
+		} else if (sgio_type == TYPE_MOD &&
+				cmd[0] != GPCMD_GET_PERFORMANCE) {
+			return 0;
+		} else if (sgio_type != TYPE_DISK &&
+				sgio_type != TYPE_RBC &&
+				sgio_type != TYPE_MOD)
+			return 0;
+
+		/* DISK | RBC | MOD: fall through to ensure write access */
+	}
 
 	/* Write-safe commands require a writable open */
-	if (test_bit(cmd[0], filter->write_ok) && has_write_perm)
+	if (test_bit(cmd[0], filter->write_ok) && has_write_perm) {
+		/* REPORT_KEY is only permitted on ROM devices */
+		if (cmd[0] == GPCMD_REPORT_KEY && sgio_type != TYPE_ROM)
+			return -EPERM;
 		return 0;
+	}
 
 	return -EPERM;
 }
@@ -226,7 +261,7 @@ static int blk_fill_sghdr_rq(struct request_queue *q, struct request *rq,
 {
 	if (copy_from_user(rq->cmd, hdr->cmdp, hdr->cmd_len))
 		return -EFAULT;
-	if (blk_verify_command(rq->cmd, mode & FMODE_WRITE))
+	if (blk_verify_command(rq->cmd, mode & FMODE_WRITE, q->sgio_type))
 		return -EPERM;
 
 	/*
@@ -456,7 +491,7 @@ int sg_scsi_ioctl(struct request_queue *q, struct gendisk *disk, fmode_t mode,
 	if (in_len && copy_from_user(buffer, sic->data + cmdlen, in_len))
 		goto error;
 
-	err = blk_verify_command(rq->cmd, mode & FMODE_WRITE);
+	err = blk_verify_command(rq->cmd, mode & FMODE_WRITE, q->sgio_type);
 	if (err)
 		goto error;
 
diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
index 054ec2c..a9fe79f 100644
--- a/drivers/scsi/scsi_scan.c
+++ b/drivers/scsi/scsi_scan.c
@@ -806,6 +806,8 @@ static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,
 
 	}
 
+	sdev->request_queue->sgio_type = sdev->type;
+
 	if (sdev->type == TYPE_RBC || sdev->type == TYPE_ROM) {
 		/* RBC and MMC devices can return SCSI-3 compliance and yet
 		 * still not support REPORT LUNS, so make them act as
diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c
index eb81c98..32a23d0 100644
--- a/drivers/scsi/sg.c
+++ b/drivers/scsi/sg.c
@@ -222,7 +222,8 @@ static int sg_allow_access(struct file *filp, unsigned char *cmd)
 	if (sfp->parentdp->device->type == TYPE_SCANNER)
 		return 0;
 
-	return blk_verify_command(cmd, filp->f_mode & FMODE_WRITE);
+	return blk_verify_command(cmd, filp->f_mode & FMODE_WRITE,
+			sfp->parentdp->device->type);
 }
 
 static int
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index a693c6d..6a3a429 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -433,6 +433,7 @@ struct request_queue {
 	 */
 	unsigned int		sg_timeout;
 	unsigned int		sg_reserved_size;
+	unsigned char		sgio_type;
 	int			node;
 #ifdef CONFIG_BLK_DEV_IO_TRACE
 	struct blk_trace	*blk_trace;
@@ -1134,7 +1135,8 @@ static inline int sb_issue_zeroout(struct super_block *sb, sector_t block,
 				    gfp_mask, true);
 }
 
-extern int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm);
+extern int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm,
+		unsigned char sgio_type);
 
 enum blk_default_limits {
 	BLK_MAX_SEGMENTS	= 128,
