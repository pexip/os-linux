--- a/scripts/sign-file.c
+++ b/scripts/sign-file.c
@@ -93,12 +93,13 @@
 		return;
 	fprintf(stderr, "At main.c:%d:\n", l);
 
-	while ((e = ERR_get_error_line(&file, &line))) {
+	while ((e = ERR_get_error_all(&file, &line, NULL, NULL, NULL))) {
 		ERR_error_string(e, buf);
 		fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
 	}
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 static void drain_openssl_errors(void)
 {
 	const char *file;
@@ -108,6 +109,7 @@
 		return;
 	while (ERR_get_error_line(&file, &line)) {}
 }
+#endif
 
 #define ERR(cond, fmt, ...)				\
 	do {						\
@@ -144,6 +146,7 @@
 	EVP_PKEY *private_key;
 
 	if (!strncmp(private_key_name, "pkcs11:", 7)) {
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 		ENGINE *e;
 
 		ENGINE_load_builtin_engines();
@@ -160,6 +163,9 @@
 		private_key = ENGINE_load_private_key(e, private_key_name,
 						      NULL, NULL);
 		ERR(!private_key, "%s", private_key_name);
+#else
+		ERR(1, "OpenSSL ENGINEs not supported");
+#endif
 	} else {
 		BIO *b;
 
@@ -236,8 +242,10 @@
 	X509 *x509;
 	BIO *bd, *bm;
 	int opt, n;
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	OpenSSL_add_all_algorithms();
 	ERR_load_crypto_strings();
+#endif
 	ERR_clear_error();
 
 	key_pass = getenv("KBUILD_SIGN_PIN");
@@ -305,7 +313,9 @@
 		x509 = read_x509(x509_name);
 
 		/* Digest the module data. */
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 		OpenSSL_add_all_digests();
+#endif
 		display_openssl_errors(__LINE__);
 		digest_algo = EVP_get_digestbyname(hash_algo);
 		ERR(!digest_algo, "EVP_get_digestbyname");
--- a/tools/build/feature/test-libcrypto.c
+++ b/tools/build/feature/test-libcrypto.c
@@ -19,7 +19,14 @@
 	EVP_DigestFinal_ex(mdctx, &md[0], &digest_len);
 	EVP_MD_CTX_free(mdctx);
 
-	SHA1(&dat[0], sizeof(dat), &md[0]);
+	mdctx = EVP_MD_CTX_new();
+	if (!mdctx)
+		return 0;
+
+	EVP_DigestInit_ex(mdctx, EVP_sha1(), NULL);
+	EVP_DigestUpdate(mdctx, &dat[0], sizeof(dat));
+	EVP_DigestFinal_ex(mdctx, &md[0], &digest_len);
+	EVP_MD_CTX_free(mdctx);
 
 	return 0;
 }
--- a/tools/perf/util/genelf.c
+++ b/tools/perf/util/genelf.c
@@ -37,12 +37,11 @@
 #undef BUILD_ID_URANDOM /* different uuid for each run */
 
 #ifdef BUILD_ID_SHA
-#include <openssl/sha.h>
+#include <openssl/evp.h>
 #endif
 
 #ifdef BUILD_ID_MD5
 #include <openssl/evp.h>
-#include <openssl/md5.h>
 #endif
 #endif
 
@@ -128,10 +127,20 @@
 	     const void *code,
 	     size_t csize)
 {
+	EVP_MD_CTX *mdctx;
+	size_t digest_len;
+
 	if (sizeof(note->build_id) < SHA_DIGEST_LENGTH)
 		errx(1, "build_id too small for SHA1");
 
-	SHA1(code, csize, (unsigned char *)note->build_id);
+	mdctx = EVP_MD_CTX_new();
+	if (!mdctx)
+		errx(1, "Failed allocating EVP_MD_CTX");
+
+	EVP_DigestInit_ex(mdctx, EVP_sha1(), NULL);
+	EVP_DigestUpdate(mdctx, code, csize);
+	EVP_DigestFinal_ex(mdctx, (unsigned char *)note->build_id, &digest_len);
+	EVP_MD_CTX_free(mdctx);
 }
 #endif
 
--- a/tools/testing/selftests/sgx/sigstruct.c
+++ b/tools/testing/selftests/sgx/sigstruct.c
@@ -150,19 +150,25 @@
 	return had_errors;
 }
 
-static inline const BIGNUM *get_modulus(RSA *key)
+static inline BIGNUM *get_modulus(EVP_PKEY *key)
 {
-	const BIGNUM *n;
+	BIGNUM *n = NULL;
 
-	RSA_get0_key(key, &n, NULL, NULL);
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
+	const BIGNUM *tmp;
+	RSA_get0_key(EVP_PKEY_get0_RSA(key), &tmp, NULL, NULL);
+	n = BN_dup(tmp);
+#else
+	EVP_PKEY_get_bn_param(key, "n", &n);
+#endif
 	return n;
 }
 
-static RSA *gen_sign_key(void)
+static EVP_PKEY *gen_sign_key(void)
 {
 	unsigned long sign_key_length;
 	BIO *bio;
-	RSA *key;
+	EVP_PKEY *key;
 
 	sign_key_length = (unsigned long)&sign_key_end -
 			  (unsigned long)&sign_key;
@@ -171,7 +177,7 @@
 	if (!bio)
 		return NULL;
 
-	key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);
+	key = PEM_read_bio_PrivateKey(bio, NULL, NULL, NULL);
 	BIO_free(bio);
 
 	return key;
@@ -318,9 +324,11 @@
 	struct sgx_sigstruct *sigstruct = &encl->sigstruct;
 	struct sgx_sigstruct_payload payload;
 	uint8_t digest[SHA256_DIGEST_LENGTH];
-	EVP_MD_CTX *ctx = NULL;
 	unsigned int siglen;
-	RSA *key = NULL;
+	EVP_PKEY *key = NULL;
+	EVP_MD_CTX *ctx = NULL, *ctx2 = NULL;
+	EVP_PKEY_CTX *sctx = NULL;
+	BIGNUM *modulus = NULL;
 	int i;
 
 	memset(sigstruct, 0, sizeof(*sigstruct));
@@ -343,7 +351,12 @@
 		goto err;
 	}
 
-	BN_bn2bin(get_modulus(key), sigstruct->modulus);
+	modulus = get_modulus(key);
+	if (!modulus) {
+		ERR_print_errors_fp(stdout);
+		goto err;
+	}
+	BN_bn2bin(modulus, sigstruct->modulus);
 
 	ctx = EVP_MD_CTX_create();
 	if (!ctx)
@@ -362,13 +375,26 @@
 	if (!mrenclave_commit(ctx, sigstruct->body.mrenclave))
 		goto err;
 
+	ctx2 = EVP_MD_CTX_create();
+	if (!ctx2)
+		goto err;
+
 	memcpy(&payload.header, &sigstruct->header, sizeof(sigstruct->header));
 	memcpy(&payload.body, &sigstruct->body, sizeof(sigstruct->body));
 
-	SHA256((unsigned char *)&payload, sizeof(payload), digest);
+	EVP_DigestInit_ex(ctx2, EVP_sha256(), NULL);
+	EVP_DigestUpdate(ctx2, (unsigned char *)&payload, sizeof(payload));
+	EVP_DigestFinal_ex(ctx2, digest, &siglen);
+
+	sctx = EVP_PKEY_CTX_new(key, NULL);
+	if (!sctx)
+		goto err;
 
-	if (!RSA_sign(NID_sha256, digest, SHA256_DIGEST_LENGTH,
-		      sigstruct->signature, &siglen, key))
+	siglen = sizeof(sigstruct->signature);
+	if (EVP_PKEY_sign_init(sctx) != 1 ||
+			EVP_PKEY_CTX_set_signature_md(sctx, EVP_sha256()) != 1 ||
+			EVP_PKEY_sign(sctx, sigstruct->signature, &siglen,
+				digest, SHA256_DIGEST_LENGTH) != 1)
 		goto err;
 
 	if (!calc_q1q2(sigstruct->signature, sigstruct->modulus, sigstruct->q1,
@@ -379,13 +405,19 @@
 	reverse_bytes(sigstruct->signature, SGX_MODULUS_SIZE);
 	reverse_bytes(sigstruct->modulus, SGX_MODULUS_SIZE);
 
+	EVP_PKEY_CTX_free(sctx);
+	EVP_MD_CTX_destroy(ctx2);
 	EVP_MD_CTX_destroy(ctx);
-	RSA_free(key);
+	BN_free(modulus);
+	EVP_PKEY_free(key);
 	return true;
 
 err:
+	EVP_PKEY_CTX_free(sctx);
+	EVP_MD_CTX_destroy(ctx2);
 	if (ctx)
 		EVP_MD_CTX_destroy(ctx);
-	RSA_free(key);
+	BN_free(modulus);
+	EVP_PKEY_free(key);
 	return false;
 }
--- a/certs/extract-cert.c
+++ b/certs/extract-cert.c
@@ -50,12 +50,13 @@
 		return;
 	fprintf(stderr, "At main.c:%d:\n", l);
 
-	while ((e = ERR_get_error_line(&file, &line))) {
+	while ((e = ERR_get_error_all(&file, &line, NULL, NULL, NULL))) {
 		ERR_error_string(e, buf);
 		fprintf(stderr, "- SSL %s: %s:%d\n", buf, file, line);
 	}
 }
 
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 static void drain_openssl_errors(void)
 {
 	const char *file;
@@ -65,6 +66,7 @@
 		return;
 	while (ERR_get_error_line(&file, &line)) {}
 }
+#endif
 
 #define ERR(cond, fmt, ...)				\
 	do {						\
@@ -99,8 +101,10 @@
 	char *cert_src;
 	char *verbose_env;
 
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
 	OpenSSL_add_all_algorithms();
 	ERR_load_crypto_strings();
+#endif
 	ERR_clear_error();
 
 	verbose_env = getenv("KBUILD_VERBOSE");
@@ -122,6 +126,7 @@
 		fclose(f);
 		exit(0);
 	} else if (!strncmp(cert_src, "pkcs11:", 7)) {
+#if OPENSSL_VERSION_NUMBER < 0x30000000L
 		ENGINE *e;
 		struct {
 			const char *cert_id;
@@ -144,6 +149,9 @@
 		ENGINE_ctrl_cmd(e, "LOAD_CERT_CTRL", 0, &parms, NULL, 1);
 		ERR(!parms.cert, "Get X.509 from PKCS#11");
 		write_cert(parms.cert);
+#else
+		ERR(1, "OpenSSL ENGINEs not supported");
+#endif
 	} else {
 		BIO *b;
 		X509 *x509;
